/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

#include "phone_book.h"
#include "server_util.h"

r_val *
add_to_database_1_svc(entry *argp, struct svc_req *rqstp)
{
	static r_val  result;
	char phone_book_entry[256];

	FILE *fp = fopen("./database.txt", "a");

	strcpy(phone_book_entry, argp->name);
	strcat(phone_book_entry, "# ");
	strcat(phone_book_entry, argp->number);
	strcat(phone_book_entry, "\n");

	if(fputs(phone_book_entry, fp) < 0) {
		result.num = -1;
		result.message = malloc(sizeof(char) * 64);
		strcpy(result.message, "Error writing to file");
	}

	else {
		fclose(fp);

		int entry_count = countEntries();
		if(entry_count < 0) {
			result.num = -1;
			result.message = malloc(sizeof(char) * 64);
			strcpy(result.message, "Error counting entries");
		}
		else {
			result.num = entry_count;
			result.message = malloc(sizeof(char) * 64);
			strcpy(result.message, "Success");
		}
	}
	result.head = NULL;

	return(&result);
}

r_val *
remove_from_database_1_svc(char **argp, struct svc_req *rqstp)
{
	static r_val  result;
	FILE *fp;
	char c;
	int i;
	int found_entry = 0;

	entry *head = NULL;

	// Build data structure to hold entries
	buildList(&head);

	entry *current = head;
	entry *trail_current;

	current = head;

	while(current && !found_entry) {

		if(strcmp(current->name, *argp) == 0) {
			found_entry = 1;

			if(current == head) {
				if(head->next == NULL) {
					free(head->name);
					free(head->number);
					free(head);
				}
				else {
					trail_current = head;
					head = head->next;

					free(trail_current->name);
					free(trail_current->number);
					free(trail_current);
				}
			}
			else {
				trail_current->next = current->next;

				free(current->name);
				free(current->number);
				free(current);
			}
		}
		else {
			trail_current = current;
			current = current->next;
		}
	}

	if(!found_entry) {
		result.num = -1;
		result.message = malloc(sizeof(char) * 128);

		strcpy(result.message, "Entry not found");
	}
	else {
		if((fp = fopen("database.txt", "w")) < 0) {
			perror("Error opening file for read");
			return NULL;
		}

		current = head;
		while(current) {
			fprintf(fp, "%s# %s\n", current->name, current->number);
			current = current->next;
		}
		fclose(fp);

		int entry_count = countEntries();
		if(entry_count < 0) {
			result.num = -1;
			result.message = malloc(sizeof(char) * 64);
			strcpy(result.message, "Error counting entries");
		}
		else {
			result.num = entry_count;
			result.message = malloc(sizeof(char) * 64);
			strcpy(result.message, "Success");
		}
	}
	result.head = NULL;

	return &result;
}

r_val *
lookup_name_1_svc(char **argp, struct svc_req *rqstp)
{
	static r_val  result;
	char c;
	int i;
	int finished_build = 0;
	int found_entry = 0;

	// Build data structure to hold entries
	entry *head = NULL;

	buildList(&head);

	entry *current = head;
	entry *trail_current;

	current = head;

	while(current) {

		if(strncmp(current->name, *argp, strlen(*argp)) == 0) {
			found_entry = 1;
			current = current->next;
		}
		else {
			entry *temp = current;
			current = current->next;
			removeNode(&head, &temp);
		}
	}

	if(!found_entry) {
		result.num = -1;
		result.message = malloc(sizeof(char) * 64);;
		strcpy(result.message, "No entries beginning with those characters");
		result.head = NULL;
	}
	else {
		int entry_count = countEntries();
		if(entry_count < 0) {
			result.num = -1;
			result.message = malloc(sizeof(char) * 64);
			strcpy(result.message, "Error counting entries");
		}
		else {
			result.num = entry_count;
			result.message = malloc(sizeof(char) * 64);
			strcpy(result.message, "Success");
			result.head = head;
		}
	}

	return &result;
}

r_val *
list_1_svc(void *argp, struct svc_req *rqstp)
{
	static r_val  result;

	entry *head = NULL;

	if(buildList(&head) < 0) {
		result.num = -1;
		result.message = malloc(sizeof(char) * 64);
		strcpy(result.message, "Error compiling entries");
		result.head = NULL;
	}

	else {
		result.num = 1;
		result.message = malloc(sizeof(char) * 64);
		strcpy(result.message, "Success");
		result.head = head;
	}

	return &result;
}

int *
quit_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;
	return NULL;
}

int *
terminate_1_svc(void *argp, struct svc_req *rqstp)
{
	static int  result;

	exit(0);
}
